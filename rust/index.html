<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>draft Rust - blog</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style3.css">


    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="chapter-item expanded affix "><li class="part-title">机器学习</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../pytorch/index.html"><strong aria-hidden="true">1.</strong> PyTorch</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../pytorch/pytorch_pocket_reference.html"><strong aria-hidden="true">1.1.</strong> pytorch pocket reference 笔记</a></li><li class="chapter-item "><a href="../pytorch/mini-torch.html"><strong aria-hidden="true">1.2.</strong> mini torch</a></li></ol></li><li class="chapter-item expanded "><a href="../tengine/index.html"><strong aria-hidden="true">2.</strong> Tengine</a></li><li class="chapter-item expanded "><a href="../nlp/index.html"><strong aria-hidden="true">3.</strong> NLP</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../nlp/bert.html"><strong aria-hidden="true">3.1.</strong> Bert</a></li></ol></li><li class="chapter-item expanded "><a href="../nncase/index.html"><strong aria-hidden="true">4.</strong> nncase</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../nncase/compile_flow.html"><strong aria-hidden="true">4.1.</strong> comile流程</a></li><li class="chapter-item "><a href="../nncase/k210.html"><strong aria-hidden="true">4.2.</strong> k210 standalone sdk</a></li><li class="chapter-item "><a href="../nncase/face_detect_example.html"><strong aria-hidden="true">4.3.</strong> face detect example</a></li></ol></li><li class="chapter-item expanded "><a href="../ray/index.html"><strong aria-hidden="true">5.</strong> Ray</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ray/paper.html"><strong aria-hidden="true">5.1.</strong> Ray Paper</a></li><li class="chapter-item "><a href="../ray/remote.html"><strong aria-hidden="true">5.2.</strong> Ray Remote</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Tensorflow</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tensorflow/index.html"><strong aria-hidden="true">6.1.</strong> tensorflow inside</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tensorflow/executor.html"><strong aria-hidden="true">6.1.1.</strong> Executor: 执行Computation Sub Graph</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tensorflow/executor-subgraph-preprocess.html"><strong aria-hidden="true">6.1.1.1.</strong> SubGraph预处理：Node/NodeItem/TaggedNode</a></li><li class="chapter-item "><a href="../tensorflow/flow-control-op.html"><strong aria-hidden="true">6.1.1.2.</strong> Flow control op: switch/merge/enter/exit/nextIteration</a></li><li class="chapter-item "><a href="../tensorflow/executor-frame.html"><strong aria-hidden="true">6.1.1.3.</strong> Frame: ControlFlowInfo/FrameInfo/FrameState/IterationState</a></li></ol></li><li class="chapter-item "><a href="../tensorflow/direct-session.html"><strong aria-hidden="true">6.1.2.</strong> DirectSession: 单机执行computation graph</a></li><li class="chapter-item "><a href="../tensorflow/rendezvous.html"><strong aria-hidden="true">6.1.3.</strong> RendezVous：跨设备，跨主机通信</a></li><li class="chapter-item "><a href="../tensorflow/device.html"><strong aria-hidden="true">6.1.4.</strong> Device：计算单元抽象(CPU/GPU)</a></li></ol></li><li class="chapter-item "><a href="../tensorflow/optimize.html"><strong aria-hidden="true">6.2.</strong> tensorflow模型对接工程优化</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tensorflow/export-keras-model-as-tf-frozen-graph.html"><strong aria-hidden="true">6.2.1.</strong> 将keras模型导出为tf frozen graph</a></li><li class="chapter-item "><a href="../tensorflow/replace-placeholder-with-iterator.html"><strong aria-hidden="true">6.2.2.</strong> 使用dataset iterator 优化keras model预测的吞吐量</a></li><li class="chapter-item "><a href="../tensorflow/stat-cpu-gpu-load.html"><strong aria-hidden="true">6.2.3.</strong> 统计cpu/gpu 负载率脚本</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../pthread/index.html"><strong aria-hidden="true">7.</strong> pthread</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../pthread/pthread-primer.html"><strong aria-hidden="true">7.1.</strong> Pthread Primer笔记</a></li><li class="chapter-item "><a href="../pthread/glibc-pthread-implement-thread-life-cycle.html"><strong aria-hidden="true">7.2.</strong> Pthread线程生命周期</a></li><li class="chapter-item "><a href="../pthread/glibc-pthread-implement-sync.html"><strong aria-hidden="true">7.3.</strong> Pthread线程同步</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Rust</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../yew/index.html"><strong aria-hidden="true">8.</strong> Yew</a></li><li class="chapter-item expanded "><a href="../axum/index.html"><strong aria-hidden="true">9.</strong> Axum</a></li><li class="chapter-item expanded "><a href="../axum/hyper.html"><strong aria-hidden="true">10.</strong> Hyper</a></li><li class="chapter-item expanded "><a href="../tokio/index.html"><strong aria-hidden="true">11.</strong> tokio</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tokio/executor.html"><strong aria-hidden="true">11.1.</strong> Executor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tokio/park.html"><strong aria-hidden="true">11.1.1.</strong> Park</a></li><li class="chapter-item "><a href="../tokio/thread-pool.html"><strong aria-hidden="true">11.1.2.</strong> thread pool</a></li></ol></li><li class="chapter-item "><a href="../tokio/driver.html"><strong aria-hidden="true">11.2.</strong> driver</a></li><li class="chapter-item "><a href="../tokio/io.html"><strong aria-hidden="true">11.3.</strong> io</a></li><li class="chapter-item "><a href="../tokio/codec.html"><strong aria-hidden="true">11.4.</strong> codec</a></li><li class="chapter-item "><a href="../tokio/channel.html"><strong aria-hidden="true">11.5.</strong> channel</a></li><li class="chapter-item "><a href="../tokio/waker.html"><strong aria-hidden="true">11.6.</strong> waker</a></li></ol></li><li class="chapter-item expanded "><a href="../crossbeam/index.html"><strong aria-hidden="true">12.</strong> crossbeam</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../crossbeam/skiplist.html"><strong aria-hidden="true">12.1.</strong> SkipList(draft)</a></li></ol></li><li class="chapter-item expanded "><a href="../rust/index.html" class="active"><strong aria-hidden="true">13.</strong> draft Rust</a></li><li class="chapter-item expanded affix "><li class="part-title">GO</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../golang/index.html"><strong aria-hidden="true">14.</strong> Go</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../golang/pgm.html"><strong aria-hidden="true">14.1.</strong> Runtime PGM调度模型</a></li><li class="chapter-item "><a href="../golang/goroutine-stack.html"><strong aria-hidden="true">14.2.</strong> Goroutine Stack</a></li><li class="chapter-item "><a href="../golang/memory.html"><strong aria-hidden="true">14.3.</strong> Memory分配</a></li><li class="chapter-item "><a href="../golang/GC.html"><strong aria-hidden="true">14.4.</strong> GC</a></li><li class="chapter-item "><a href="../golang/context.html"><strong aria-hidden="true">14.5.</strong> Context</a></li><li class="chapter-item "><a href="../golang/defer-panic-recover.html"><strong aria-hidden="true">14.6.</strong> defer-panic-recover</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">数据库</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../leveldb/index.html"><strong aria-hidden="true">15.</strong> LevelDB</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../leveldb/draft.html"><strong aria-hidden="true">15.1.</strong> draft</a></li><li class="chapter-item "><a href="../leveldb/code-struct.html"><strong aria-hidden="true">15.2.</strong> 代码模块间关系</a></li><li class="chapter-item "><a href="../leveldb/write.html"><strong aria-hidden="true">15.3.</strong> Write 流程</a></li><li class="chapter-item "><a href="../leveldb/read.html"><strong aria-hidden="true">15.4.</strong> Read 流程</a></li><li class="chapter-item "><a href="../leveldb/table-format.html"><strong aria-hidden="true">15.5.</strong> SSTable 文件格式和读写</a></li><li class="chapter-item "><a href="../leveldb/versionset.html"><strong aria-hidden="true">15.6.</strong> versionset和Manifest</a></li><li class="chapter-item "><a href="../leveldb/table-compact.html"><strong aria-hidden="true">15.7.</strong> Do Compact</a></li><li class="chapter-item "><a href="../leveldb/iterator.html"><strong aria-hidden="true">15.8.</strong> Iterator迭代器</a></li><li class="chapter-item "><a href="../leveldb/bloom-filter.html"><strong aria-hidden="true">15.9.</strong> Bloom filter</a></li></ol></li><li class="chapter-item expanded "><a href="../rocksdb/index.html"><strong aria-hidden="true">16.</strong> RocksDB</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../rocksdb/draft.html"><strong aria-hidden="true">16.1.</strong> draft</a></li><li class="chapter-item "><a href="../rocksdb/column-family.html"><strong aria-hidden="true">16.2.</strong> 主要struct引用关系</a></li><li class="chapter-item "><a href="../rocksdb/wal.html"><strong aria-hidden="true">16.3.</strong> Write Ahead Log</a></li><li class="chapter-item "><a href="../rocksdb/write.html"><strong aria-hidden="true">16.4.</strong> write 并发控制</a></li><li class="chapter-item "><a href="../rocksdb/flush-and-compact.html"><strong aria-hidden="true">16.5.</strong> 后台flush和compact线程</a></li><li class="chapter-item "><a href="../rocksdb/leveled-compaction-picker.html"><strong aria-hidden="true">16.6.</strong> Leveled Compaction Picker</a></li><li class="chapter-item "><a href="../rocksdb/read.html"><strong aria-hidden="true">16.7.</strong> read 流程</a></li><li class="chapter-item "><a href="../rocksdb/blob.html"><strong aria-hidden="true">16.8.</strong> Blob</a></li><li class="chapter-item "><a href="../rocksdb/transaction.html"><strong aria-hidden="true">16.9.</strong> 事务</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../rocksdb/optimistic-transaction.html"><strong aria-hidden="true">16.9.1.</strong> Optimistic Transaction</a></li><li class="chapter-item "><a href="../rocksdb/transaction-lock-mgr.html"><strong aria-hidden="true">16.9.2.</strong> Transaction lock mgr</a></li><li class="chapter-item "><a href="../rocksdb/two-phase-commit.html"><strong aria-hidden="true">16.9.3.</strong> two phase commit</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../clickhouse/index.html"><strong aria-hidden="true">17.</strong> ClickHouse(daft)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../clickhouse/server-main.html"><strong aria-hidden="true">17.1.</strong> Server main</a></li><li class="chapter-item "><a href="../clickhouse/block.html"><strong aria-hidden="true">17.2.</strong> block</a></li><li class="chapter-item "><a href="../clickhouse/blockio.html"><strong aria-hidden="true">17.3.</strong> blockio</a></li><li class="chapter-item "><a href="../clickhouse/storage.html"><strong aria-hidden="true">17.4.</strong> Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../clickhouse/merge-tree-data.html"><strong aria-hidden="true">17.4.1.</strong> MergeTreeData</a></li><li class="chapter-item "><a href="../clickhouse/storage-merge-tree.html"><strong aria-hidden="true">17.4.2.</strong> StorageMergeTree</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">PingCAP</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../tidb/index.html"><strong aria-hidden="true">18.</strong> TiDB</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tidb/note.html"><strong aria-hidden="true">18.1.</strong> tidb学习资料整理</a></li><li class="chapter-item "><a href="../tidb/main.html"><strong aria-hidden="true">18.2.</strong> Server Main Loop</a></li><li class="chapter-item "><a href="../tidb/insert.html"><strong aria-hidden="true">18.3.</strong> Insert 语句</a></li><li class="chapter-item "><a href="../tidb/select.html"><strong aria-hidden="true">18.4.</strong> Select 语句</a></li><li class="chapter-item "><a href="../tidb/types.html"><strong aria-hidden="true">18.5.</strong> 数据类型</a></li><li class="chapter-item "><a href="../tidb/expression.html"><strong aria-hidden="true">18.6.</strong> expression</a></li><li class="chapter-item "><a href="../tidb/ddl.html"><strong aria-hidden="true">18.7.</strong> Online DDL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tidb/ddl-schema-in-tikv.html"><strong aria-hidden="true">18.7.1.</strong> Schema 存储</a></li><li class="chapter-item "><a href="../tidb/ddl-schema-load.html"><strong aria-hidden="true">18.7.2.</strong> Schema Cache和加载</a></li><li class="chapter-item "><a href="../tidb/ddl-schema-modification.html"><strong aria-hidden="true">18.7.3.</strong> Schema Modification</a></li><li class="chapter-item "><a href="../tidb/ddl-online-schema-change.html"><strong aria-hidden="true">18.7.4.</strong> Online Schema Change</a></li></ol></li><li class="chapter-item "><a href="../tidb/stat.html"><strong aria-hidden="true">18.8.</strong> 统计信息</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tidb/basic-concepts.html"><strong aria-hidden="true">18.8.1.</strong> 基本概念</a></li><li class="chapter-item "><a href="../tidb/stat-tables.html"><strong aria-hidden="true">18.8.2.</strong> stats tables</a></li><li class="chapter-item "><a href="../tidb/stat-analyze.html"><strong aria-hidden="true">18.8.3.</strong> Analyze</a></li><li class="chapter-item "><a href="../tidb/stat-feedback.html"><strong aria-hidden="true">18.8.4.</strong> Query Feedback</a></li><li class="chapter-item "><a href="../tidb/use-stat.html"><strong aria-hidden="true">18.8.5.</strong> 统计信息使用场景</a></li></ol></li><li class="chapter-item "><a href="../tidb/logical-optimize.html"><strong aria-hidden="true">18.9.</strong> Logical Optimize</a></li><li class="chapter-item "><a href="../tidb/physical-optimize.html"><strong aria-hidden="true">18.10.</strong> Physical Optimize</a></li><li class="chapter-item "><a href="../tidb/datasource.html"><strong aria-hidden="true">18.11.</strong> DataSource</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tidb/datasource-build.html"><strong aria-hidden="true">18.11.1.</strong> buildDataSource</a></li><li class="chapter-item "><a href="../tidb/range.html"><strong aria-hidden="true">18.11.2.</strong> 索引范围计算</a></li><li class="chapter-item "><a href="../tidb/tablecodec.html"><strong aria-hidden="true">18.11.3.</strong> table/index存储编码</a></li><li class="chapter-item "><a href="../tidb/datasource-paritionProcessor.html"><strong aria-hidden="true">18.11.4.</strong> paritionProcessor</a></li><li class="chapter-item "><a href="../tidb/datasource-predict-push-down.html"><strong aria-hidden="true">18.11.5.</strong> PredicatePushDown</a></li><li class="chapter-item "><a href="../tidb/datasource-physical-optimize.html"><strong aria-hidden="true">18.11.6.</strong> Physical Optimize</a></li><li class="chapter-item "><a href="../tidb/datasource-executors.html"><strong aria-hidden="true">18.11.7.</strong> Executors</a></li></ol></li><li class="chapter-item "><a href="../tidb/distsql.html"><strong aria-hidden="true">18.12.</strong> DistSQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tidb/cop-region-cache.html"><strong aria-hidden="true">18.12.1.</strong> ReginCache</a></li><li class="chapter-item "><a href="../tidb/tikv-grpc-client.html"><strong aria-hidden="true">18.12.2.</strong> TiKV GRPC Client</a></li><li class="chapter-item "><a href="../tidb/cop-task.html"><strong aria-hidden="true">18.12.3.</strong> CopTask</a></li><li class="chapter-item "><a href="../tidb/cop-iterator-worker.html"><strong aria-hidden="true">18.12.4.</strong> CopIteratorWorker</a></li><li class="chapter-item "><a href="../tidb/coprocessor.html"><strong aria-hidden="true">18.12.5.</strong> Coprocessor</a></li></ol></li><li class="chapter-item "><a href="../tidb/join.html"><strong aria-hidden="true">18.13.</strong> Join</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tidb/join-alg.html"><strong aria-hidden="true">18.13.1.</strong> Join算法</a></li><li class="chapter-item "><a href="../tidb/join-logical-optimize.html"><strong aria-hidden="true">18.13.2.</strong> Logical Optimize</a></li><li class="chapter-item "><a href="../tidb/join-physical-optimize.html"><strong aria-hidden="true">18.13.3.</strong> Physical Optimize</a></li><li class="chapter-item "><a href="../tidb/hash-join.html"><strong aria-hidden="true">18.13.4.</strong> Executor: Hash Join</a></li><li class="chapter-item "><a href="../tidb/merge-join.html"><strong aria-hidden="true">18.13.5.</strong> Executor: Merge Join</a></li><li class="chapter-item "><a href="../tidb/index-lookup-join.html"><strong aria-hidden="true">18.13.6.</strong> Executor: Index Lookup Join</a></li></ol></li><li class="chapter-item "><a href="../tidb/agg.html"><strong aria-hidden="true">18.14.</strong> Agg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tidb/agg-func.html"><strong aria-hidden="true">18.14.1.</strong> AggFunc</a></li><li class="chapter-item "><a href="../tidb/hash-agg.html"><strong aria-hidden="true">18.14.2.</strong> Executor: HashAgg</a></li><li class="chapter-item "><a href="../tidb/stream-agg.html"><strong aria-hidden="true">18.14.3.</strong> Executor: StreamAgg</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../pd/index.html"><strong aria-hidden="true">19.</strong> PD</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../tikv/index.html"><strong aria-hidden="true">20.</strong> TiKV</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tikv/raft2.html"><strong aria-hidden="true">20.1.</strong> raft-rs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tikv/raft_rawnode.html"><strong aria-hidden="true">20.1.1.</strong> RawNode</a></li><li class="chapter-item "><a href="../tikv/raft_storage.html"><strong aria-hidden="true">20.1.2.</strong> Storage</a></li><li class="chapter-item "><a href="../tikv/progress_tracker.html"><strong aria-hidden="true">20.1.3.</strong> ProgressTracker</a></li><li class="chapter-item "><a href="../tikv/raft_hearbeat.html"><strong aria-hidden="true">20.1.4.</strong> Hearbeat</a></li><li class="chapter-item "><a href="../tikv/raft_election.html"><strong aria-hidden="true">20.1.5.</strong> Election</a></li><li class="chapter-item "><a href="../tikv/raft_log_entry.html"><strong aria-hidden="true">20.1.6.</strong> LogEntry</a></li><li class="chapter-item "><a href="../tikv/raft_snapshot.html"><strong aria-hidden="true">20.1.7.</strong> Snapshot</a></li><li class="chapter-item "><a href="../tikv/raft_conf_change.html"><strong aria-hidden="true">20.1.8.</strong> ConfChange</a></li><li class="chapter-item "><a href="../tikv/raft_read_index.html"><strong aria-hidden="true">20.1.9.</strong> ReadIndex</a></li></ol></li><li class="chapter-item "><a href="../tikv/raft-kv.html"><strong aria-hidden="true">20.2.</strong> RaftKV</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tikv/batch-system2.html"><strong aria-hidden="true">20.2.1.</strong> BatchSystem</a></li><li class="chapter-item "><a href="../tikv/raft_message.html"><strong aria-hidden="true">20.2.2.</strong> RaftMessage</a></li><li class="chapter-item "><a href="../tikv/raft_client.html"><strong aria-hidden="true">20.2.3.</strong> Raft Client</a></li><li class="chapter-item "><a href="../tikv/region2.html"><strong aria-hidden="true">20.2.4.</strong> Region</a></li><li class="chapter-item "><a href="../tikv/peer_storage2.html"><strong aria-hidden="true">20.2.5.</strong> PeerStorage</a></li><li class="chapter-item "><a href="../tikv/thread_local_engine.html"><strong aria-hidden="true">20.2.6.</strong> Thread Local Engine</a></li><li class="chapter-item "><a href="../tikv/leader_lease.html"><strong aria-hidden="true">20.2.7.</strong> Leader Lease</a></li><li class="chapter-item "><a href="../tikv/read_index.html"><strong aria-hidden="true">20.2.8.</strong> Read Index</a></li><li class="chapter-item "><a href="../tikv/async_snapshot2.html"><strong aria-hidden="true">20.2.9.</strong> Async Snapshot</a></li><li class="chapter-item "><a href="../tikv/async_write2.html"><strong aria-hidden="true">20.2.10.</strong> Async Write</a></li><li class="chapter-item "><a href="../tikv/region_epoch.html"><strong aria-hidden="true">20.2.11.</strong> Region Epoch</a></li><li class="chapter-item "><a href="../tikv/conf_change2.html"><strong aria-hidden="true">20.2.12.</strong> Conf Change</a></li><li class="chapter-item "><a href="../tikv/split_region2.html"><strong aria-hidden="true">20.2.13.</strong> Split Region</a></li><li class="chapter-item "><a href="../tikv/merge_region2.html"><strong aria-hidden="true">20.2.14.</strong> Merge Region</a></li></ol></li><li class="chapter-item "><a href="../tikv/storage2.html"><strong aria-hidden="true">20.3.</strong> Storage</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tikv/percolator.html"><strong aria-hidden="true">20.3.1.</strong> Percolator</a></li><li class="chapter-item "><a href="../tikv/percolator_in_tikv.html"><strong aria-hidden="true">20.3.2.</strong> Percolator In TiKV</a></li><li class="chapter-item "><a href="../tikv/tikv_2pc.html"><strong aria-hidden="true">20.3.3.</strong> 2PC</a></li><li class="chapter-item "><a href="../tikv/async_commit.html"><strong aria-hidden="true">20.3.4.</strong> AsyncCommit</a></li><li class="chapter-item "><a href="../tikv/tikv_1pc.html"><strong aria-hidden="true">20.3.5.</strong> OnePC</a></li><li class="chapter-item "><a href="../tikv/pessimistic_lock.html"><strong aria-hidden="true">20.3.6.</strong> 悲观事务</a></li><li class="chapter-item "><a href="../tikv/txn_recovery.html"><strong aria-hidden="true">20.3.7.</strong> Resolve Lock</a></li><li class="chapter-item "><a href="../tikv/scheduler2.html"><strong aria-hidden="true">20.3.8.</strong> Scheduler</a></li><li class="chapter-item "><a href="../tikv/wait_lock.html"><strong aria-hidden="true">20.3.9.</strong> Wait Lock</a></li><li class="chapter-item "><a href="../tikv/dead_lock.html"><strong aria-hidden="true">20.3.10.</strong> 死锁检测</a></li><li class="chapter-item "><a href="../tikv/group_commit.html"><strong aria-hidden="true">20.3.11.</strong> TiDB分组提交</a></li><li class="chapter-item "><a href="../tikv/storage_scanner.html"><strong aria-hidden="true">20.3.12.</strong> Scanner</a></li></ol></li><li class="chapter-item "><a href="../tikv/coprocessor.html"><strong aria-hidden="true">20.4.</strong> Coprocessor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tikv/rpn_expression.html"><strong aria-hidden="true">20.4.1.</strong> RpnExpression</a></li><li class="chapter-item "><a href="../tikv/aggr_function.html"><strong aria-hidden="true">20.4.2.</strong> AggrFunction</a></li><li class="chapter-item "><a href="../tikv/batch_executor.html"><strong aria-hidden="true">20.4.3.</strong> BatchExecutor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tikv/ranges_scanner.html"><strong aria-hidden="true">20.4.3.1.</strong> RangesScanner</a></li><li class="chapter-item "><a href="../tikv/scan_executor.html"><strong aria-hidden="true">20.4.3.2.</strong> ScanExecutor</a></li><li class="chapter-item "><a href="../tikv/batch_executor_selection.html"><strong aria-hidden="true">20.4.3.3.</strong> Selection</a></li><li class="chapter-item "><a href="../tikv/batch_executor_agg.html"><strong aria-hidden="true">20.4.3.4.</strong> AggExecutor</a></li></ol></li></ol></li><li class="chapter-item "><a href="../tikv/performance.html"><strong aria-hidden="true">20.5.</strong> Performance(draft)</a></li><li class="chapter-item "><a href="../tikv/yatp.html"><strong aria-hidden="true">20.6.</strong> yatp</a></li></ol></li><li class="chapter-item expanded "><a href="../bevy/index.html"><strong aria-hidden="true">21.</strong> Bevy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../bevy/first-impression-draft.html"><strong aria-hidden="true">21.1.</strong> bevy draft</a></li></ol></li><li class="chapter-item expanded "><a href="../blender/index.html"><strong aria-hidden="true">22.</strong> Blender</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../blender/manual-notes.html"><strong aria-hidden="true">22.1.</strong> blender manual notes</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Trash</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../python/index.html"><strong aria-hidden="true">23.1.</strong> python</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../python/records/records.html"><strong aria-hidden="true">23.1.1.</strong> records</a></li></ol></li><li class="chapter-item "><a href="../react/index.html"><strong aria-hidden="true">23.2.</strong> react</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../react/from-jsx-to-dom.html"><strong aria-hidden="true">23.2.1.</strong> 从jsx到html dom的流程分析</a></li></ol></li><li class="chapter-item "><a href="../godot/index.html"><strong aria-hidden="true">23.3.</strong> Godot</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../godot/learning-note.html"><strong aria-hidden="true">23.3.1.</strong> godot 学习笔记</a></li><li class="chapter-item "><a href="../godot/gdquest.html"><strong aria-hidden="true">23.3.2.</strong> gdquest tutorial</a></li></ol></li><li class="chapter-item "><a href="../kafka/index.html"><strong aria-hidden="true">23.4.</strong> Kafka</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../kafka/client-producer.html"><strong aria-hidden="true">23.4.1.</strong> client: producer</a></li><li class="chapter-item "><a href="../kafka/group-coordinator.html"><strong aria-hidden="true">23.4.2.</strong> group coordinator</a></li><li class="chapter-item "><a href="../kafka/kafka-produce-fetch.html"><strong aria-hidden="true">23.4.3.</strong> produce and fetch</a></li><li class="chapter-item "><a href="../kafka/log.html"><strong aria-hidden="true">23.4.4.</strong> log</a></li><li class="chapter-item "><a href="../kafka/partition.html"><strong aria-hidden="true">23.4.5.</strong> Partition</a></li><li class="chapter-item "><a href="../kafka/controller-main.html"><strong aria-hidden="true">23.4.6.</strong> Controller</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../kafka/controller-channel-manager.html"><strong aria-hidden="true">23.4.6.1.</strong> 通信管理 channelManager</a></li><li class="chapter-item "><a href="../kafka/controller-elect.html"><strong aria-hidden="true">23.4.6.2.</strong> 选举</a></li><li class="chapter-item "><a href="../kafka/controller-zk.html"><strong aria-hidden="true">23.4.6.3.</strong> zk监听处理</a></li></ol></li><li class="chapter-item "><a href="../kafka/replica-assignment.html"><strong aria-hidden="true">23.4.7.</strong> 副本迁移</a></li><li class="chapter-item "><a href="../kafka/paritition-replica-statemachine.html"><strong aria-hidden="true">23.4.8.</strong> Partition/Replica状态机</a></li><li class="chapter-item "><a href="../kafka/txn_coordinator.html"><strong aria-hidden="true">23.4.9.</strong> 事务</a></li><li class="chapter-item "><a href="../kafka/stream.html"><strong aria-hidden="true">23.4.10.</strong> Stream</a></li></ol></li><li class="chapter-item "><a href="../java/index.html"><strong aria-hidden="true">23.5.</strong> hotspot</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../java/hotspot-debug-under-osx.html"><strong aria-hidden="true">23.5.1.</strong> osx下编译调试hotspot</a></li><li class="chapter-item "><a href="../java/hotspot-thread-created-when-init.html"><strong aria-hidden="true">23.5.2.</strong> jvm的初始化时创建的线程</a></li><li class="chapter-item "><a href="../java/hotspot-class-file-load-and-run.html"><strong aria-hidden="true">23.5.3.</strong> class文件的加载和执行</a></li></ol></li><li class="chapter-item "><a href="../papers/index.html"><strong aria-hidden="true">23.6.</strong> Paper notes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../papers/raft.html"><strong aria-hidden="true">23.6.1.</strong> raft paper</a></li><li class="chapter-item "><a href="../papers/gfs.html"><strong aria-hidden="true">23.6.2.</strong> draft: gfs</a></li><li class="chapter-item "><a href="../papers/bw-tree.html"><strong aria-hidden="true">23.6.3.</strong> draft: Bw-tree(draft)</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">blog</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="rust"><a class="header" href="#rust">rust</a></h1>
<h2 id="books-futures-explained"><a class="header" href="#books-futures-explained">books futures explained</a></h2>
<p>https://cfsamson.github.io/books-futures-explained/0_background_information.html</p>
<h3 id="os-thread-green-threads-callback-based-async-task"><a class="header" href="#os-thread-green-threads-callback-based-async-task">OS Thread, Green Threads, Callback based, Async task</a></h3>
<p>Green threads use the same mechanism as an OS - creating a thread for each task, setting up a stack, saving the CPU's state, and jumping from one task(thread) to another by doing a &quot;context switch&quot;.</p>
<p>async, await, Future, Pin</p>
<p>GreenThread 有点像GO的做法.</p>
<p>GreenThread做法</p>
<ol>
<li>Run some non-blocking code.</li>
<li>Make a blocking call to some external resource.</li>
<li>CPU &quot;jumps&quot; to the &quot;main&quot; thread which schedules a different thread to run and &quot;jumps&quot; to that stack.</li>
<li>Run some non-blocking code on the new thread until a new blocking call or the task is finished.</li>
<li>CPU &quot;jumps&quot; back to the &quot;main&quot; thread, schedules a new thread which is ready to make progress, and &quot;jumps&quot; to that thread.</li>
</ol>
<p>GreenThread DrawBacks</p>
<ol>
<li>The stacks might need to grow. Solving this is not easy and will have a cost.</li>
<li>You need to save the CPU state on every switch.</li>
<li>It's not a zero cost abstraction (Rust had green threads early on and this was one of the reasons they were removed).</li>
<li>Complicated to implement correctly if you want to support many different platforms.</li>
</ol>
<p>去看下GO是怎么解决 1/2的</p>
<p>这个代码可以要仔细研究下
https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(llvm_asm, naked_functions)]
use std::ptr;

const DEFAULT_STACK_SIZE: usize = 1024 * 1024 * 2;
const MAX_THREADS: usize = 4;
static mut RUNTIME: usize = 0;

pub struct Runtime {
    threads: Vec&lt;Thread&gt;,
    current: usize,
}

#[derive(PartialEq, Eq, Debug)]
enum State {
    Available,
    Running,
    Ready,
}

struct Thread {
    id: usize,
    stack: Vec&lt;u8&gt;,
    ctx: ThreadContext,
    state: State,
    task: Option&lt;Box&lt;dyn Fn()&gt;&gt;,
}

#[derive(Debug, Default)]
#[repr(C)]
struct ThreadContext {
    rsp: u64,
    r15: u64,
    r14: u64,
    r13: u64,
    r12: u64,
    rbx: u64,
    rbp: u64,
    thread_ptr: u64,
}

impl Thread {
    fn new(id: usize) -&gt; Self {
        Thread {
            id,
            stack: vec![0_u8; DEFAULT_STACK_SIZE],
            ctx: ThreadContext::default(),
            state: State::Available,
            task: None,
        }
    }
}

impl Runtime {
    pub fn new() -&gt; Self {
        let base_thread = Thread {
            id: 0,
            stack: vec![0_u8; DEFAULT_STACK_SIZE],
            ctx: ThreadContext::default(),
            state: State::Running,
            task: None,
        };

        let mut threads = vec![base_thread];
        threads[0].ctx.thread_ptr = &amp;threads[0] as *const Thread as u64;
        let mut available_threads: Vec&lt;Thread&gt; = (1..MAX_THREADS).map(|i| Thread::new(i)).collect();
        threads.append(&amp;mut available_threads);

        Runtime {
            threads,
            current: 0,
        }
    }

    pub fn init(&amp;self) {
        unsafe {
            let r_ptr: *const Runtime = self;
            RUNTIME = r_ptr as usize;
        }
    }

    pub fn run(&amp;mut self) -&gt; ! {
        while self.t_yield() {}
        std::process::exit(0);
    }

    fn t_return(&amp;mut self) {
        if self.current != 0 {
            self.threads[self.current].state = State::Available;
            self.t_yield();
        }
    }

    fn t_yield(&amp;mut self) -&gt; bool {
        let mut pos = self.current;
        while self.threads[pos].state != State::Ready {
            pos += 1;
            if pos == self.threads.len() {
                pos = 0;
            }
            if pos == self.current {
                return false;
            }
        }

        if self.threads[self.current].state != State::Available {
            self.threads[self.current].state = State::Ready;
        }

        self.threads[pos].state = State::Running;
        let old_pos = self.current;
        self.current = pos;

        unsafe {
           let old: *mut ThreadContext = &amp;mut self.threads[old_pos].ctx;
           let new: *const ThreadContext = &amp;self.threads[pos].ctx;
           llvm_asm!(
               &quot;mov $0, %rdi
                mov $1, %rsi&quot;::&quot;r&quot;(old), &quot;r&quot;(new)
           );
           switch();
       }
        true
    }

    pub fn spawn&lt;F: Fn() + 'static&gt;(f: F){
        unsafe {
            let rt_ptr = RUNTIME as *mut Runtime;
            let available = (*rt_ptr)
                .threads
                .iter_mut()
                .find(|t| t.state == State::Available)
                .expect(&quot;no available thread.&quot;);

            let size = available.stack.len();
            let s_ptr = available.stack.as_mut_ptr().offset(size as isize);
            let s_ptr = (s_ptr as usize &amp; !15) as *mut u8;
            available.task = Some(Box::new(f));
            available.ctx.thread_ptr = available as *const Thread as u64;
            //ptr::write(s_ptr.offset((size - 8) as isize) as *mut u64, guard as u64);
            std::ptr::write(s_ptr.offset(-16) as *mut u64, guard as u64);
            std::ptr::write(s_ptr.offset(-24) as *mut u64, skip as u64);
            std::ptr::write(s_ptr.offset(-32) as *mut u64, call as u64);
            available.ctx.rsp = s_ptr.offset(-32) as u64;
            available.state = State::Ready;
        }
    }
}

fn call(thread: u64) {
    let thread = unsafe { &amp;*(thread as *const Thread) };
    if let Some(f) = &amp;thread.task {
        f();
    }
}

#[naked]
fn skip() { }

fn guard() {
    unsafe {
        let rt_ptr = RUNTIME as *mut Runtime;
        let rt = &amp;mut *rt_ptr;
        println!(&quot;THREAD {} FINISHED.&quot;, rt.threads[rt.current].id);
        rt.t_return();
    };
}

pub fn yield_thread() {
    unsafe {
        let rt_ptr = RUNTIME as *mut Runtime;
        (*rt_ptr).t_yield();
    };
}

#[naked]
#[inline(never)]
unsafe fn switch() {
    llvm_asm!(&quot;
       mov     %rsp, 0x00(%rdi)
       mov     %r15, 0x08(%rdi)
       mov     %r14, 0x10(%rdi)
       mov     %r13, 0x18(%rdi)
       mov     %r12, 0x20(%rdi)
       mov     %rbx, 0x28(%rdi)
       mov     %rbp, 0x30(%rdi)

       mov     0x00(%rsi), %rsp
       mov     0x08(%rsi), %r15
       mov     0x10(%rsi), %r14
       mov     0x18(%rsi), %r13
       mov     0x20(%rsi), %r12
       mov     0x28(%rsi), %rbx
       mov     0x30(%rsi), %rbp
       mov     0x38(%rsi), %rdi
       &quot;
   );
}
#[cfg(not(windows))]
fn main() {
    let mut runtime = Runtime::new();
    runtime.init();
    Runtime::spawn(|| {
        println!(&quot;I haven't implemented a timer in this example.&quot;);
        yield_thread();
        println!(&quot;Finally, notice how the tasks are executed concurrently.&quot;);
    });
    Runtime::spawn(|| {
        println!(&quot;But we can still nest tasks...&quot;);
        Runtime::spawn(|| {
            println!(&quot;...like this!&quot;);
        })
    });
    runtime.run();
}
</code></pre></pre>
<p>promises return a state machine which can be in one of three states: pending, fulfilled or rejected</p>
<p>promise三个状态: pending, fulfilled, rejected</p>
<pre><code class="language-javascript">function timer(ms) {
    return new Promise((resolve) =&gt; setTimeout(resolve, ms));
}

timer(200)
.then(() =&gt; timer(100))
.then(() =&gt; timer(50))
.then(() =&gt; console.log(&quot;I'm the last one&quot;));
</code></pre>
<pre><code>async function run() {
    await timer(200);
    await timer(100);
    await timer(50);
    console.log(&quot;I'm the last one&quot;);
}
</code></pre>
<p>Since promises are re-written as state machines, they also enable an even better syntax which allows us to write our last example like this:</p>
<p>state machines? 为什么 promise可以被rewrite为state machines?</p>
<h2 id="futures"><a class="header" href="#futures">Futures</a></h2>
<p>A future is a representation of some operation which will complete in the future.</p>
<p>Async in Rust uses a Poll based approach, in which an asynchronous task will have three phases.</p>
<ol>
<li>The Poll phase. A Future is polled which results in the task progressing until a point where it can no longer make progress. We often refer to the part of the runtime which polls a Future as an executor.</li>
<li>The Wait phase. An event source, most often referred to as a reactor, registers that a Future is waiting for an event to happen and makes sure that it will wake the Future when that event is ready.</li>
<li>The Wake phase. The event happens and the Future is woken up. It's now up to the executor which polled the Future in step 1 to schedule the future to be polled again and make further progress until it completes or reaches a new point where it can't make further progress and the cycle repeats.</li>
</ol>
<h3 id="leaf-future-non-leaf-future"><a class="header" href="#leaf-future-non-leaf-future">leaf future, non-leaf future</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stream = tokio::net::TcpStream::connect(&quot;127.0.0.1:3000&quot;);
``

Operations on these resources, like a Read on a socket, will be non-blocking and return a future which we call a leaf future since it's the future which we're actually waiting on.

## non-leaf future

Non-leaf-futures are the kind of futures we as users of a runtime write ourselves using the async keyword to create a task which can be run on the executor.

```rust
let non_leaf = async {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:3000&quot;).await.unwrap();// &lt;- yield
    println!(&quot;connected!&quot;);
    let result = stream.write(b&quot;hello world\n&quot;).await; // &lt;- yield
    println!(&quot;message sent!&quot;);
    ...
};
<span class="boring">}
</span></code></pre></pre>
<p>The key to these tasks is that they're able to yield control to the runtime's scheduler and then resume execution again where it left off at a later point.</p>
<p>yield 地方下次poll时候，会接着执行。 这个是怎么实现的？有点像thread context switch时候保存stack ptr,下次来的时候，接着执行了。</p>
<p>不知道rust是怎么实现的? state每次  async 对应的task结构是？
switch(state) {
case state1:
xxx code
yield: set state to state2
case state2:
xxx code
}</p>
<p>In contrast to leaf futures, these kind of futures do not themselves represent an I/O resource. 
When we poll them they will run until they get to a leaf-future which returns Pending and then yield control to the scheduler (which is a part of what we call the runtime).</p>
<p>Mental Model</p>
<p>A fully working async system in Rust can be divided into three parts:</p>
<p>Reactor
Executor
Future</p>
<p>Reactor 表示最底层事件？</p>
<p>So, how does these three parts work together? 
They do that through an object called the Waker.
The Waker is how the reactor tells the executor that a specific Future is ready to run.
Once you understand the life cycle and ownership of a Waker, you'll understand how futures work from a user's perspective.
Here is the life cycle:</p>
<p>A Waker is created by the executor. 
A common, but not required, method is to create a new Waker for each Future that is registered with the executor.</p>
<p>When a future is registered with an executor, 
it’s given a clone of the Waker object created by the executor.
Since this is a shared object (e.g. an Arc<T>), all clones actually point to the same underlying object.
Thus, anything that calls any clone of the original Waker will wake the particular Future that was registered to it.</p>
<p>The future clones the Waker and passes it to the reactor, which stores it to use later.</p>
<p>Rust 标准库关注的：接口..</p>
<p>What Rust's standard library takes care of</p>
<ol>
<li>
<p>A common interface representing an operation which will be completed in the future through the Future trait.</p>
</li>
<li>
<p>An ergonomic way of creating tasks which can be suspended and resumed through the async and await keywords.</p>
</li>
<li>
<p>A defined interface to wake up a suspended task through the Waker type.</p>
</li>
</ol>
<p>async keyward rewrites our code block to a state machine. Each await point represents a state change.</p>
<p>a waker i spassed into Future::poll, iT wil hang on to thath waker</p>
<p>until it reaches an <code>await</code> point. when it does it will call <code>poll</code> on that future and pass the waker along</p>
<p>We don't actually pass a Waker directly, we pass the waker as a aprt of an object call <code>Context</code> which might add extra 
context to the poll method in the future.</p>
<p>Reactor just caretes an object implementing the <code>Future</code> trait and returns it.</p>
<p>leaf_fut.poll(waker)</p>
<h2 id="trait-object"><a class="header" href="#trait-object">Trait object</a></h2>
<p>fat pointer</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::mem::size_of;
trait SomeTrait { }

fn main() {
    println!(&quot;======== The size of different pointers in Rust: ========&quot;);
    println!(&quot;&amp;dyn Trait:------{}&quot;, size_of::&lt;&amp;dyn SomeTrait&gt;());
    println!(&quot;&amp;[&amp;dyn Trait]:---{}&quot;, size_of::&lt;&amp;[&amp;dyn SomeTrait]&gt;());
    println!(&quot;Box&lt;Trait&gt;:------{}&quot;, size_of::&lt;Box&lt;SomeTrait&gt;&gt;());
    println!(&quot;Box&lt;Box&lt;Trait&gt;&gt;:-{}&quot;, size_of::&lt;Box&lt;Box&lt;SomeTrait&gt;&gt;&gt;());
    println!(&quot;&amp;i32:------------{}&quot;, size_of::&lt;&amp;i32&gt;());
    println!(&quot;&amp;[i32]:----------{}&quot;, size_of::&lt;&amp;[i32]&gt;());
    println!(&quot;Box&lt;i32&gt;:--------{}&quot;, size_of::&lt;Box&lt;i32&gt;&gt;());
    println!(&quot;&amp;Box&lt;i32&gt;:-------{}&quot;, size_of::&lt;&amp;Box&lt;i32&gt;&gt;());
    println!(&quot;[&amp;dyn Trait;4]:--{}&quot;, size_of::&lt;[&amp;dyn SomeTrait; 4]&gt;());
    println!(&quot;[i32;4]:---------{}&quot;, size_of::&lt;[i32; 4]&gt;());
}
</code></pre></pre>
<p>The layout for a pointer to a trait object looks like this:</p>
<p>The first 8 bytes points to the data for the trait object
The second 8 bytes points to the vtable for the trait object</p>
<p>fat pointer, vtable</p>
<pre><pre class="playground"><code class="language-rust edition2021">
use std::mem::{align_of, size_of};

// A reference to a trait object is a fat pointer: (data_ptr, vtable_ptr)
trait Test {
    fn add(&amp;self) -&gt; i32;
    fn sub(&amp;self) -&gt; i32;
    fn mul(&amp;self) -&gt; i32;
}

// This will represent our home-brewed fat pointer to a trait object
#[repr(C)]
struct FatPointer&lt;'a&gt; {
    /// A reference is a pointer to an instantiated `Data` instance
    data: &amp;'a mut Data,
    /// Since we need to pass in literal values like length and alignment it's
    /// easiest for us to convert pointers to usize-integers instead of the other way around.
    vtable: *const usize,
}

// This is the data in our trait object. It's just two numbers we want to operate on.
struct Data {
    a: i32,
    b: i32,
}

// ====== function definitions ======
fn add(s: &amp;Data) -&gt; i32 {
    s.a + s.b
}
fn sub(s: &amp;Data) -&gt; i32 {
    s.a - s.b
}
fn mul(s: &amp;Data) -&gt; i32 {
    s.a * s.b
}

fn main() {
    let mut data = Data {a: 3, b: 2};
    // vtable is like special purpose array of pointer-length types with a fixed
    // format where the three first values contains some general information like
    // a pointer to drop and the length and data alignment of `data`.
    let vtable = vec![
        0,                  // pointer to `Drop` (which we're not implementing here)
        size_of::&lt;Data&gt;(),  // length of data
        align_of::&lt;Data&gt;(), // alignment of data

        // we need to make sure we add these in the same order as defined in the Trait.
        add as usize, // function pointer - try changing the order of `add`
        sub as usize, // function pointer - and `sub` to see what happens
        mul as usize, // function pointer
    ];

    let fat_pointer = FatPointer { data: &amp;mut data, vtable: vtable.as_ptr()};
    let test = unsafe { std::mem::transmute::&lt;FatPointer, &amp;dyn Test&gt;(fat_pointer) };

    // And voalá, it's now a trait object we can call methods on
    println!(&quot;Add: 3 + 2 = {}&quot;, test.add());
    println!(&quot;Sub: 3 - 2 = {}&quot;, test.sub());
    println!(&quot;Mul: 3 * 2 = {}&quot;, test.mul());
}
</code></pre></pre>
<p>std::mem::transmute</p>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/2033-experimental-coroutines.md">rust generator的 RFC</a></p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async]
fn print_lines() -&gt; io::Result&lt;()&gt; {
    let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
    let tcp = await!(TcpStream::connect(&amp;addr))?;
    let io = BufReader::new(tcp);

    #[async]
    for line in io.lines() {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}


fn print_lines() -&gt; impl Future&lt;Item = (), Error = io::Error&gt; {
    lazy(|| {
        let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
        TcpStream::connect(&amp;addr).and_then(|tcp| {
            let io = BufReader::new(tcp);

            io.lines().for_each(|line| {
                println!(&quot;{}&quot;, line);
                Ok(())
            })
        })
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>State machines as &quot;stackless coroutines&quot;</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_lines() -&gt; impl Future&lt;Item = (), Error = io::Error&gt; {
    CoroutineToFuture(|| {
        let addr = &quot;127.0.0.1:8080&quot;.parse().unwrap();
        let tcp = {
            let mut future = TcpStream::connect(&amp;addr);
            loop {
                match future.poll() {
                    Ok(Async::Ready(e)) =&gt; break Ok(e),
                    Ok(Async::NotReady) =&gt; yield, //这块的yield, 怎么记住state , 下次进来怎么resume ?
                    Err(e) =&gt; break Err(e),
                }
            }
        }?;

        let io = BufReader::new(tcp);

        let mut stream = io.lines();
        loop {
            let line = {
                match stream.poll()? {
                    Async::Ready(Some(e)) =&gt; e,
                    Async::Ready(None) =&gt; break,
                    Async::NotReady =&gt; {
                        yield;
                        continue
                    }
                }
            };
            println!(&quot;{}&quot;, line);
        }

        Ok(())
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>yield 关键字:
the most prominent addition here is the usage of yield keywords. These are inserted here to inform the compiler that the coroutine should be suspended for later resumption</p>
<p>问题: Coroutine::resume是怎么实现的？</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CoroutineToFuture&lt;T&gt;(T);

impl&lt;T: Coroutine&gt; Future for CoroutineToFuture {
    type Item = T::Item;
    type Error = T::Error;

    fn poll(&amp;mut self) -&gt; Poll&lt;T::Item, T::Error&gt; {
    //不知道Coroutine::resume 这个是怎么实现的
        match Coroutine::resume(&amp;mut self.0) {
            CoroutineStatus::Return(Ok(result)) =&gt; Ok(Async::Ready(result)),
            CoroutineStatus::Return(Err(e)) =&gt; Err(e),
            CoroutineStatus::Yield =&gt; Ok(Async::NotReady),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>设计要点</p>
<ol>
<li>No implicit memory allocation</li>
<li>Coroutines are translated to state machines internally by the compiler</li>
<li>The standard library has the traits/types necessary to support the coroutines language feature.</li>
</ol>
<blockquote>
<p>As a result, coroutines will roughly compile down to a state machine that's advanced forward as its resumed. Whenever a coroutine yields it'll leave itself in a state that can be later resumed from the yield statement.
这个是怎么实现的呢？</p>
</blockquote>
<h2 id="yield关键字"><a class="header" href="#yield关键字">yield关键字</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(generators, generator_trait)]
use std::ops::{Generator, GeneratorState};

fn main() {
    let a: i32 = 4;
    let mut gen = move || {
        println!(&quot;Hello&quot;);
        yield a * 2;
        println!(&quot;world!&quot;);
    };

    if let GeneratorState::Yielded(n) = gen.resume() {
        println!(&quot;Got value {}&quot;, n);
    }

    if let GeneratorState::Complete(()) = gen.resume() {
        ()
    };
}
</code></pre></pre>
<p>https://tmandry.gitlab.io/blog/posts/optimizing-await-1/</p>
<p>std::mem::replace 这个类似于c里面的memcp ?</p>
<p>std::mem::replace(self, GeneratorA::Exit</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../crossbeam/skiplist.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../golang/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../crossbeam/skiplist.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../golang/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "rust/index.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/custom.js"></script>
        <script type="text/javascript" src="../assets/bigPicture.js"></script>


    </body>
</html>